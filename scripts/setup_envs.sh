#!/usr/bin/env bash
set -euo pipefail

# setup_envs.sh
# Create per-model virtual environments and install the right requirements.
# - env3: Qwen-VL + WhisSent deps (requirements/requirements_env3.txt)
# - env4: Gemma3 deps (requirements/requirements_env4.txt)
# - env5: Qwen3 deps (requirements/requirements_env5.txt)
# - env-lb: Load balancer + minimal deps (requirements/requirements.txt)
#
# Usage examples:
#   scripts/setup_envs.sh                    # create env3 env4 env5 env-lb under .venvs
#   scripts/setup_envs.sh env3 env5          # only create env3 and env5
#   scripts/setup_envs.sh --venv-dir /opt/orchestra-venvs
#   scripts/setup_envs.sh --python-bin /usr/bin/python3.11
#   scripts/setup_envs.sh --recreate         # delete and recreate existing envs
#   scripts/setup_envs.sh --no-write-exports # do not generate orchestra.env
#
# After running, source the exports:
#   source ./orchestra.env
#

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
REQ_DIR="$REPO_ROOT/requirements"

# Defaults
VENV_DIR_DEFAULT="$REPO_ROOT/.venvs"
VENV_DIR="${VENV_DIR:-$VENV_DIR_DEFAULT}"
PYTHON_BIN="${PYTHON_BIN:-}"
RECREATE=0
WRITE_EXPORTS=1

# Choose a Python binary if not provided
choose_python() {
  if [[ -n "$PYTHON_BIN" ]]; then
    echo "$PYTHON_BIN"
    return 0
  fi
  if command -v python3.11 >/dev/null 2>&1; then
    echo "$(command -v python3.11)"
  elif command -v python3 >/dev/null 2>&1; then
    echo "$(command -v python3)"
  else
    echo "ERROR: python3.11 or python3 not found in PATH" >&2
    exit 1
  fi
}

print_help() {
  cat <<EOF
Create per-model virtual environments and install requirements.

Options:
  --venv-dir DIR        Target directory for virtualenvs (default: $VENV_DIR_DEFAULT)
  --python-bin PATH     Python interpreter to use for venv creation (default: auto-detect)
  --recreate            Remove and recreate envs even if they already exist
  --no-write-exports    Do not write ./orchestra.env exports file
  -h, --help            Show this help

Positional args (optional, default: env3 env4 env5 lb):
  env3  Qwen-VL + WhisSent environment (requirements_env3.txt)
  env4  Gemma3 environment (requirements_env4.txt)
  env5  Qwen3 environment (requirements_env5.txt)
  lb    Load balancer + minimal deps (requirements.txt)

Examples:
  scripts/setup_envs.sh
  scripts/setup_envs.sh env3 env5
  scripts/setup_envs.sh --venv-dir /opt/orchestra-venvs --python-bin /usr/bin/python3.11
EOF
}

# Parse args
ENVS=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    --venv-dir)
      VENV_DIR="$2"; shift 2;;
    --python-bin)
      PYTHON_BIN="$2"; shift 2;;
    --recreate)
      RECREATE=1; shift;;
    --no-write-exports)
      WRITE_EXPORTS=0; shift;;
    -h|--help)
      print_help; exit 0;;
    env3|env4|env5|lb)
      ENVS+=("$1"); shift;;
    *)
      echo "Unknown argument: $1" >&2; print_help; exit 1;;
  esac
done

if [[ ${#ENVS[@]} -eq 0 ]]; then
  ENVS=(env3 env4 env5 lb)
fi

PY_BIN="$(choose_python)"
mkdir -p "$VENV_DIR"

create_env() {
  local name="$1"; shift
  local req_file="$1"; shift
  local venv_path="$VENV_DIR/$name"
  echo "==> Setting up $name at $venv_path"
  if [[ -d "$venv_path" ]]; then
    if [[ "$RECREATE" -eq 1 ]]; then
      echo "Removing existing env: $venv_path"
      rm -rf "$venv_path"
    else
      echo "Env exists, skipping creation: $venv_path"
    fi
  fi
  if [[ ! -d "$venv_path" ]]; then
    "$PY_BIN" -m venv "$venv_path"
  fi
  # Upgrade pip tooling and install requirements
  "$venv_path/bin/python" -m pip install --upgrade pip setuptools wheel
  if [[ -f "$req_file" ]]; then
    echo "Installing from $req_file"
    "$venv_path/bin/pip" install -r "$req_file"
  else
    echo "ERROR: Requirements file not found: $req_file" >&2
    exit 1
  fi
}

LB_CHOSEN="lb" # default LB uses dedicated env

for env in "${ENVS[@]}"; do
  case "$env" in
    env3)
      create_env "env3" "$REQ_DIR/requirements_env3.txt";;
    env4)
      create_env "env4" "$REQ_DIR/requirements_env4.txt";;
    env5)
      create_env "env5" "$REQ_DIR/requirements_env5.txt";;
    lb)
      create_env "env-lb" "$REQ_DIR/requirements.txt"; LB_CHOSEN="lb";;
  esac
done

echo "\nAll requested environments set up in: $VENV_DIR"

if [[ "$WRITE_EXPORTS" -eq 1 ]]; then
  GEMMA_PY="$VENV_DIR/env4/bin/python"
  QWEN_PY="$VENV_DIR/env3/bin/python"
  QWEN3_PY="$VENV_DIR/env5/bin/python"
  WHISSENT_PY="$VENV_DIR/env3/bin/python"
  if [[ "$LB_CHOSEN" == "lb" ]]; then
    LB_PY="$VENV_DIR/env-lb/bin/python"
  else
    LB_PY="$GEMMA_PY"
  fi
  cat > "$REPO_ROOT/orchestra.env" <<EOF
# Generated by scripts/setup_envs.sh
export GEMMA_PYTHON_PATH="$GEMMA_PY"
export QWEN_PYTHON_PATH="$QWEN_PY"
export QWEN3_PYTHON_PATH="$QWEN3_PY"
export WHISSENT_PYTHON_PATH="$WHISSENT_PY"
# Dedicated environment for the load balancer
export LOAD_BALANCER_PYTHON_PATH="$LB_PY"
EOF
  echo "Wrote exports to $REPO_ROOT/orchestra.env"
  echo "To use in this shell/session: source ./orchestra.env"
  echo "run_api.sh will also honor these if you export them before starting."
else
  echo "Skipping exports file per --no-write-exports"
fi
